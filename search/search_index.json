{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pointextract","text":"<p>Polar to cartesian transforms using annular point sampling.</p> <p>Designed to unwrap 2D cross section images of 3D X-ray computed tomography scans. The topological transformation enables the surface of a circular or elliptical object to be \"unwrapped\" for downsteam analysis.</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<p>You can install the package with: <pre><code>pip install pointextract\n</code></pre></p>"},{"location":"#example","title":"Example","text":"<p>Simple example: <pre><code>import pointextract\nfrom skimage import io, filters\n\nimg_arr = io.imread('./data/sample.png')\n\nimg_thresh = img_arr &gt; filters.threshold_otsu(img_arr)\nellipse = ellipse_detect(img_thresh)\n\nimg_unwrap = unwrap_image(img_arr, ellipse, radial_distance=20, num_points=800)\n</code></pre></p>"},{"location":"#functions","title":"Functions","text":""},{"location":"#pointextract.main.ellipse_detect","title":"<code>ellipse_detect(img_arr, sigma=1.0)</code>","text":"<p>Detect an ellipse in a given image array using edge detection and ellipse fitting.</p> <p>Parameters:</p> Name Type Description Default <code>img_arr</code> <code>ndarray</code> <p>The input image array.</p> required <code>sigma</code> <code>float</code> <p>The standard deviation of the Gaussian filter used in edge detection. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Name Type Description <code>EllipseModel</code> <code>EllipseModel</code> <p>Fitted ellipse object from scikit-image.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the ellipse fitting fails.</p> Source code in <code>pointextract/main.py</code> <pre><code>def ellipse_detect(img_arr: np.ndarray, sigma: float = 1.0) -&gt; EllipseModel:\n    \"\"\"\n    Detect an ellipse in a given image array using edge detection and ellipse fitting.\n\n    Args:\n        img_arr (np.ndarray): The input image array.\n        sigma (float, optional): The standard deviation of the Gaussian filter used in edge detection. Defaults to 1.0.\n\n    Returns:\n        EllipseModel: Fitted ellipse object from scikit-image.\n\n    Raises:\n        ValueError: If the ellipse fitting fails.\n    \"\"\"\n    edges = canny(img_arr, sigma=sigma)\n    points = np.argwhere(edges != 0)\n    ellipse = EllipseModel()\n    if not ellipse.estimate(points):\n        raise ValueError('Ellipse fitting failed. Try adjusting the sigma value or check the input image.')\n    return ellipse\n</code></pre>"},{"location":"#pointextract.main.unwrap_circle","title":"<code>unwrap_circle(img_arr, radius, center, points)</code>","text":"<p>Unwrap a circular region of an image into a linear array.</p> <p>Parameters:</p> Name Type Description Default <code>img_arr</code> <code>ndarray</code> <p>The input image array.</p> required <code>radius</code> <code>int</code> <p>The radius of the circle to unwrap.</p> required <code>center</code> <code>Tuple[int, int]</code> <p>The (y, x) coordinates of the circle's center.</p> required <code>points</code> <code>int</code> <p>The number of points to sample along the circle.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A 1D numpy array containing the pixel values of the unwrapped circle.</p> Source code in <code>pointextract/main.py</code> <pre><code>def unwrap_circle(img_arr: np.ndarray, radius: int, center: Tuple[int, int], points: int) -&gt; np.ndarray:\n    \"\"\"\n    Unwrap a circular region of an image into a linear array.\n\n    Args:\n        img_arr (np.ndarray): The input image array.\n        radius (int): The radius of the circle to unwrap.\n        center (Tuple[int, int]): The (y, x) coordinates of the circle's center.\n        points (int): The number of points to sample along the circle.\n\n    Returns:\n        np.ndarray: A 1D numpy array containing the pixel values of the unwrapped circle.\n    \"\"\"\n    def build_circle(r: int, num_points: int) -&gt; Tuple[np.ndarray, np.ndarray]:\n        \"\"\"Generate x and y coordinates for a circle given a radius and number of points.\"\"\"\n        t = np.linspace(0, 2 * np.pi, num_points)\n        x = r * np.cos(t)\n        y = r * np.sin(t)\n        return x.astype(int), y.astype(int)\n\n    def center_circle(center: Tuple[int, int], x: np.ndarray, y: np.ndarray) -&gt; List[Tuple[int, int]]:\n        \"\"\"Translate circle coordinates to be centered around a given point.\"\"\"\n        x = np.asarray(x) + int(center[1])  # x corresponds to columns (center[1])\n        y = np.asarray(y) + int(center[0])  # y corresponds to rows (center[0])\n        return list(zip(x, y))\n\n    def extract_img_pix(points: List[Tuple[int, int]], img_arr: np.ndarray) -&gt; np.ndarray:\n        \"\"\"Extract pixel values from the image at specified points.\"\"\"\n        return np.array([img_arr[y, x] for x, y in points])\n\n    x, y = build_circle(radius, points)\n    circle_points = center_circle(center, x, y)\n    array_circle = extract_img_pix(circle_points, img_arr)\n    return array_circle\n</code></pre>"},{"location":"#pointextract.main.unwrap_image","title":"<code>unwrap_image(img_arr, ellipse, radial_distance=20, points=600)</code>","text":"<p>Unwrap an annular region of an image centered around a specified ellipse into a 2D array.</p> <p>Parameters:</p> Name Type Description Default <code>img_arr</code> <code>ndarray</code> <p>The input image array.</p> required <code>ellipse</code> <code>EllipseModel</code> <p>Ellipse object from scikit-image.</p> required <code>radial_distance</code> <code>int</code> <p>The radial distance from the base radius to start and end unwrapping. Defaults to 20.</p> <code>20</code> <code>points</code> <code>int</code> <p>The number of points to sample along each circle. Defaults to 400.</p> <code>600</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: A 2D numpy array representing the unwrapped annular region.</p> Source code in <code>pointextract/main.py</code> <pre><code>def unwrap_image(img_arr: np.ndarray, ellipse: EllipseModel, radial_distance: int = 20, points: int = 600) -&gt; np.ndarray:\n    \"\"\"\n    Unwrap an annular region of an image centered around a specified ellipse into a 2D array.\n\n    Args:\n        img_arr (np.ndarray): The input image array.\n        ellipse (EllipseModel): Ellipse object from scikit-image.\n        radial_distance (int, optional): The radial distance from the base radius to start and end unwrapping. Defaults to 20.\n        points (int, optional): The number of points to sample along each circle. Defaults to 400.\n\n    Returns:\n        np.ndarray: A 2D numpy array representing the unwrapped annular region.\n    \"\"\"\n    xc, yc, a, b, theta = ellipse.params\n    inner_radius = int(a) - radial_distance\n    outer_radius = int(a) + radial_distance\n    unwrapped_img = unwrap_circle(img_arr, outer_radius, (xc, yc), points)\n    for i in reversed(range(inner_radius, outer_radius)):\n        current_circle = unwrap_circle(img_arr, i, (xc, yc), points)\n        unwrapped_img = np.vstack([unwrapped_img, current_circle])\n    return unwrapped_img\n</code></pre>"}]}